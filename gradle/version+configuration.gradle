import java.io.File;

ext {
	// current user
	username = System.properties["user.name"]
	
	config = Version.loadConfiguration(project.rootDir, username)
}

version = new Version(project.rootDir)
defaultTasks "build"

// publishing configuration
group = config.project.group

// java config
sourceCompatibility = config.java.source
compileJava.options.encoding = "UTF-8"

println "*** Using JDK: ${System.properties.'java.home'}"

gradle.taskGraph.whenReady { taskGraph ->
	
	if( taskGraph.hasTask(buildRelease)) {
		version.release = true
		version.env = ""
	}
	else if (taskGraph.hasTask(buildSnapshot)) {
		version.env = ""
		version.conf = "SNAPSHOT"
	}
	else {
    	new File("${projectDir}/src/main/config/${username}").mkdir()
		version.conf = "DEV"
	}

	sourceSets.main.resources.srcDir "${projectDir}/src/main/config/${version.env}"
	
 	println "*** Building version ${version}\n"
}

/**
 * Version
 */
class Version {
	int major, minor, revision
	boolean release
	String conf = ""
	String env = System.properties["user.name"]

	String toString() {
		"$major.$minor.$revision${env != "" ? "." + env : ""}${release ? "" : "-" + conf}"
	}
	
	Version(File rootDir) {
		File versionFile = new File("${rootDir}/version.properties")
		
		if (!versionFile.exists()) {
			throw new GradleException("Required version file does not exist: $versionFile.canonicalPath")
		}
		
		def versionProps = new ConfigSlurper().parse(versionFile.toURL())

		this.major    = versionProps.major
		this.minor    = versionProps.minor
		this.revision = versionProps.revision
	}
	
	/**
	 * load user dependend build configuration
	 */
	static loadConfiguration(File rootDir, String username) {		
		File defaultConfigFile = new File("${rootDir}/config/gradle/default.config")
		File userConfigFile = new File("${rootDir}/config/gradle/${username}.config")
	
		def parsedConfig = new ConfigSlurper().parse(defaultConfigFile.toURL())
		
		if (userConfigFile.exists()) {
			def parsedUserConfig = new ConfigSlurper().parse(userConfigFile.toURL())
			parsedConfig = parsedConfig.merge(parsedUserConfig)
		}
		
		return parsedConfig
	}
}